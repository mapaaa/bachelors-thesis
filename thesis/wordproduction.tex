\chapter{Reconstruc»õie de cuvinte latinesti}
\label{chap:two}
Pornim de la formele cuvintelor din limbile romanice moderne. Fiind date mai multe perechi de cuvinte
cognate vrem sa deducem forma latinescului stramos comun. Aplicam o metoda similara cu cea folosita
in \cite{theone}. Ca si in \cite{theone}, ne bazam pe faptul ca modificarile ortografice sunt strans
legate de evolutia cuvintelor. Deci incercam sa reconstruim proto-cuvinte din forma ortografica a
cuvintelor moderne.

In final, dorim sa obtinem o lista cu $n$ cele mai bune predictii pe care mai apoi sa le prelucam
intr-o maniera atat automata cat si manuala pentru a obtine cele mai bune rezultate.

\section{Prezentare generala}
Dat fiind mai multe seturi de date de cuvinte cognate din limbi romanice moderne, metoda de 
reconstructie va incerca sa aproximeze forma latinescului de provenienta. Vom folosi: \textit{Romana},
\textit{Italiana}, \textit{Franceza}, \textit{Spaniola}, \textit{Portugheza}, iar seturile de date
vor avea forma $(\textit{cuvant modern}, \textit{cuvant latinesc})$. Din acestea, modelul va invata 
pe baza campurilor conditionate aleatoare (\textit{conditional random fields} sau prescurtat CRF) 
diverse schimbari de ortografie suferite de cuvintele latinesti pentru a le forma pe cele moderne. 
Apoi, vom aplica o tehnica de agregare a acestor rezultate pentru a combina informatie din toate 
limbile. In final, vom folosi mai apoi aceste schimbari pentru a oferi variante de cuvinte ce 
completeaza anumite seturi de date.

Pasii algoritmului pentru o anumita limba romanica moderna sunt:

\begin{enumerate}
  \item Pentru fiecare pereche $(\textit{cuvant modern}, \textit{cuvant latinesc})$, vom alinia
    cele doua cuvinte pentru a intelege ce semne ortografice s-au pastrat, schimbat sau elidat.
  \item Pregatim antrenarea sistemului CRF: extragem caracteristici din alinierile fiecarei perechi.
  \item Rulam sistemul CRF si obtinem liste de $n$ cele mai bune productii sortate in functie de
    probabilitatea lor.
\end{enumerate}

\section{Aliniere}
Avem perechi de tipul $(\textit{cuvant modern}, \textit{cuvant latinesc})$ pe care vrem sa le aliniem.
Nu orice aliniere ne ofera informatie valida. Avem nevoie de asa numitele alinieri optime, in care
numarul de diferente dintre cele doua cuvinte este minim. Vom aplica algoritmul de aliniere 
Needleman-Wunsch\cite{needle} din bioinfomatica, folosit cu succes si in probleme de procesare al
limbajului natural. 

\subsection{Needleman-Wunsch}
Algoritmul de aliniere Needleman-Wunsch provine din bioinfomatica, mai exact din alinierea secventelor
de proteine sau nucleotide. Determinarea alinierilor se face printr-o tehnica
de programare dinamica. Asadar, problema initiala va fi impartita in subprobleme fie deja calculate,
fie mai usor de calculat. De fiecare cand vom spune alinieri ne vom referi doar la alinieri de tip
Needleman-Wunsch.

Avem doua siruri $a=a_1a_2...a_n$ si $b=b_1b_2...b_m$ de caractere de lungime $n$ respectiv $m$. 
Vrem sa aliniem sirul $b$ pentru a se potrivi cu sirul $a$.  

Exista 3 tipuri de operatii intr-o aliniere la o anumita pozitie $i$:
\begin{enumerate}
  \item \textbf{Potrivire}, caracterele aliniate se potrivesc: $a_i=b_i$
  \item \textbf{Nepotrivire}, caracterele aliniate nu se potrivesc: $a_i \neq b_i$
  \item \textbf{Spatiu}, caracterul din primul sir nu se aliniaza cu niciun caracter din al doilea sir
    sau invers;
\end{enumerate}

Se observa ca in cazul operatiei de tipul 3, caracterele din dreapta pozitiei curente $i$ se vor
deplasa cu o pozitie.

Fiecare dintre operatiile de mai sus are un anumit cost. In problema noastra de aliniere a unui
cuvant latinesc cu un cuvant modern, vom considera costul unei operatii de \textbf{Potrvire} ca fiind $0$,
iar costul unei operatii de \textbf{Nepotrivire} sau \textbf{Spatiu} ca fiind 1. Atfel, alinierea
optima va fi cea cu costul minim. In procesul de potrivire nu  vom lua in considerare diacriticele.
Literele ce contin astfel de semne vor fi considerate la fel cu literele de baza (spre exemplu,
caracterul \textit{\`{e}} poate fi potrivit cu \textit{e}).

Problema se rezolva folosind tehnica programarii dinamice. Definim
doua matrici bidimensionale cu $n+1$ si $m+1$ coloane numerotate de $0$ la $n$ respectiv de la $0$
la $m$:

\begin{gather*}
  D_{i,j} = \text{costul minim pentru a alinia prefixul } a_1a_2...a_i \text{ din sirul a} \\
  \text{cu prefixul } b_1b_2...b_j \text{ din sirul b} \\
  P_{i,j} = \text{ultima operatie efectuata } \textbf{Potrivire }, \textbf{Nepotrivire } \text{sau} 
  \textbf{ Spatiu}
\end{gather*}

Consideram faptul ca prefixul vid va fi reprezentat de pozitia fie cu linia $0$ (in cazul in care
prefixul vid provine din sirul $a$), fie cu coloana $0$ (in cazul in care prefixul vid provine
din sirul $b$).

Relatia de recurenta este:
\begin{gather*}
  D_{0,j} = j, \forall j=0,...,m \\
  D_{i,0} = i, \forall i=0,...,n \\
  D_{i,j} = \min \begin{dcases}
      D_{i-1,j-1}       &, a_i=b_j \textbf{ Potrivire} \\
      D_{i-1,j-1}+1     &, a_i \neq b_j \textbf{ Nepotrivire} \\
      D_{i-1,j}         &, \textbf{ Spatiu} \\
      D_{i,j-1}         &, \textbf{ Spatiu} \\
    \end{dcases}
\end{gather*}

Scorul alinierii se va afla pe pozitia $D_{n,m}$. Pentru a reconstitui alinierea, la fiecare pas din 
recurenta trebuie sa retinem in matricea $P$ matrice ultima operatie efectuata. Acum, pornim cu doi
indici $i = n$ si $j = m$. Daca pentru a rezolva subproblema determinata de prefixele $a_1a_2...a_i$
si $b_1b_2...b_j$ am folosit ca si ultima operatie:

\begin{itemize}
  \item \textbf{Potrivire}: aliniem caracterul de pe pozitia $i$ din $a$ cu cel de pe pozitia $j$ 
    din $b$; decrementam indicii $i$ si $j$  
  \item \textbf{Spatiu}: deducem daca spatiul este in sirul $a$ sau $b$ si refacem indicii corespunzator
    (daca spatiul provine din sirul $a$ atunci decrementam indicele $j$, iar daca spatiul provine
    din sirul $b$ decrementam indicele $i$
  \item \textbf{Nepotrivire}: aliniem caracterele diferite de pe pozitiile $i$ din $a$ si $j$ din $b$;
    decrementam indicii $i$ si $j$
\end{itemize}

    
\section{Campuri conditionate aleatoare}
In continuare vrem sa invatam care sunt schimbarile ortografice produse in evolutia unui cuvant
modern stiind etimonul sau. In sectiunea precedenta am aliniat cuvintele pentru a determina ce 
modificari au suferit caracterele. Folosim un algoritm de invatare automata pentru a studia
sabloane de schimbari ortografice dintre fiecare limba moderna si limba latina.

Propunem o metoda bazata de campuri conditionate aleatoare, intrucat acestea au dat rezultate 
satisfacatoare in generarea transliteratiilor \cite{ganesh} si in productia de cuvinte cognate \cite{crfciobanu}.

Vom explica mai intai cateva notiuni despre campurile conditionate aleatoare iar apoi le vom aplica 
pe problema reconstructiei de cuvinte.

\subsection{Generalitati}
Campurilor conditionate aleatoare (\textit{conditional random fields} sau prescurtat CRF) sunt o
metoda de modelare statistica pentru a face predictii structurate.

Lafferty, McCallum si Pereira\cite{crf} sunt primii care explica aceasta structura. Ei introduc un 
nou cadru pentru construirea modelelelor probabilistice pentru segmentarea si etichetarea datelor
secventiale. Pana in acel moment, astfel de probleme erau rezolvate prin modele Markov ascunse si 
gramatica stocastica.

Conform \cite{crf}, fie $X$ o variabile aleatoare peste secvente de date ce trebuie etichetate si 
$Y$ o varibila aleatoare peste etichetele corespunzatoare. Construim un model de probabilitati
conditionate $P(Y|X)$ din perechile de secvente de date si etichete.

\begin{definition}
Fie $G=(V, E)$ un graf astfel incat $Y=(Y_i)_{i \in V}$ (nodurile grafului reprezinta
indecsii etichetelor $Y$). $(X, Y)$ se numeste camp conditionat aleator daca variabila aleatoare
$Y_v$ conditionata de $X$ respecta propietatea Markov raportat la graful G: 
  \begin{gather*}
    P(Y_v | X, Y_w, w \neq v) = P(Y_v | X, Y_w, w \sim v)
  \end{gather*}
unde $w \sim v$ inseamna ca exista muchia $(w, v)$ in $E$.
\end{definition}

Observam ca CRF-ul este global conditionat de variabila $X$. Graful $G$ este nedirectionat, construit
diferit in functie de atributele secventelor de etichetat dar de cele mai multe ori are forma unui
lant sau arbore.

Pentru atribute, vom defini o functie pentru a reprezenta caracteristici ale secventelor de date.
Valoarea acestor functii se calculeaza in functie de problema pe care dorim sa o rezolvam. Le vom nota
cu $f_k$, $g_k$ etc. Spre exemplu $g_k(v, y|S, x)$ va fi adevarat daca cuvantul X incepe cu o majuscula,
iar eticheta $Y$ este "substantiv propiu".\cite{crf} $y|S$ reprezinta  setul de componente ale lui $Y$
asociate cu nodurile subgrafului $S$. Functiile de atribute trebuie calculate inaintea aplicarii
sistemului CRF.

Atribuim fiecarui atribut o anumita pondere $\lambda_i$ (pentru atributele in raport cu muchile grafului $G$)
si $\mu_i$ (pentru atributele reportate la nodurile grafului $G$). Acestea sunt valorile pe care algoritmul
trebuie sa le invete pentru a face mai apoi predictiile.

Exista doua structuri de grafuri pe care se preteaza sa aplicam sistemul CRF: cele lant si cele
arborescente.

Formula probabilitatilor conditionate pentru structura de arbore este:
\begin{gather*}
  P(Y|X) \propto \exp(\smashoperator{\sum_{e \in E, k}} \lambda_k f_k(e, y|e, x) + \smashoperator{\sum_{v \in V, k}} \mu_k g_k(v, y|v, x))
\end{gather*}

Formula probabilitatilor conditionate pentru structura de lant vom nota $start = Y_0$ si $stop = Y_{n+1}$
Probabilitatile conditionate le vom calcula intr-o matrice $M$ astfel:
\begin{gather*}
  M_i(y', y|x) = exp(\Lambda_i(y', y|x)) \\
  \Lambda_i(y', y|x) = \smashoperator{\sum_k} \lambda_k f_k(e_i, Y|e_i = (y', y), x) +
                       \smashoperator{\sum_k} \mu_k g_k(v_i, Y|v_i = y, x).
\end{gather*}
unde, $e_i$ este muchia cu etichetele $(Y_{i-1}, Y_i)$ si $v_i$ este este nodul corespondent lui $Y_i$. 

Pentru a estima parametrii $\lambda_i$ si $\mu_i$ se folosesc algoritmi iterativi pentru a maximiza
rezultatele pe un set de date de antrenare. Algoritmii sunt prezentati in \cite{crf}.

Acum pute scrie formula pentru probabilitatile conditionate pentru un graf de tip lant:
\begin{gather*}
  P(Y|X) \propto \frac{\smashoperator{\prod_{i=1}^{n+1}} M_i(y_{i-1}, y_i | x)}{(\smashoperator{\prod_{i=1}^{n+1}} M_i(x))_{start,stop}}
\end{gather*}

Precum si in alte modele statistice ce folosesc probabilitati conditionate (spre exemplu: Naive Bayes),
predictia se face prin:

\begin{gather*}
  \hat{Y} = argmax_Y(P(Y|X))
\end{gather*}

Putem lua chiar si primele $n$ cele mai bune probabilitati pentru face o analiza in profunzime.

\subsection{Aplicate pe problema reconstructiei cuvintelor}
\label{subs:one}
Ne intoarcem la problema de predictie a cuvintelor latinesti pornind de la cuvinte moderne folosind 
sisteme CRF. Secventele de date vor fi cuvintele moderne. Atributele vor fi $n$-grame din cuvintele
de intrare, extrase din ferestre de dimensiune $w$. 

Etichetele se calculeaza folosind algoritmul de aliniere, folosind caracterele ce se potrivesc in 
cuvantul modern si cuvantul latinesc. Dar, pentru ca cele doua cuvinte nu sunt complet identice,
in cazul unei inserari vom pune caracterul adaugat la eticheta precedenta (nu putem asocia acesta
litera cu niciuna din cuvantul de intrare). In cazul unui spatiu, aparut in cuvantul latinesc se 
produce practic un fenomen de elidare. Asociem caracterului respectiv din cuvantul sursa, o eticheta
noua (spre exemplu $-$) pentru a semnifica disparitia acestuia.

Sistemul are nevoie de margini la capetele cuvintelor, in cazul in care avem insertii produse la 
inceputul sau sfarsitul cuvantului, adica o eticheta "precedenta" cu care sa asociem aceste litere noi.
Asadar, fiecare cuvant va fi exstins prin adaugarea a doua caractere \textbf{B} si \textbf{E} la 
inceputul si sfarsitul acestuia.\cite{theone} Orice litera noua adaugata la inceput sau sfarsit, va
fi asociata cu aceste 2 litere speciale.


Folosim 5 astfel de sisteme CRF pentru fiecare limba moderna \textit{romana}, \textit{italiana}, 
\textit{franceza}, \textit{spaniola}, \textit{portugheza} pusa in raport cu \textit{limba latina}.
Fiecare sistem va calcula liste de cele mai bune $n$ cuvinte latinesti sortate in functie de 
probabilitate. Pentru a profita de toate limbile moderne propunem o metoda de combinare a rezultatelor
sistemelor CRF bazata pe agregari folosind distanta rank.
